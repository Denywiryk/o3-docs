import Image from "next/image";
import { Callout } from "nextra-theme-docs";

# Overview

<Callout emoji="ℹ️" type="info">
  Significant changes to the architecture of the app shell and frontend modules
  are coming in the very near future. Keep track of these changes by following
  the [Migration Guide](/docs/migration-guide).
</Callout>

Frontend modules are the basic building blocks of O3. Frontend modules get organized into monorepos based on their specific domain. For example, frontend modules concerning the management of patients exist in the patient management repository. These include:

- [Appointments](https://github.com/openmrs/openmrs-esm-patient-management/tree/main/packages/esm-appointments-app)
- [Patient search](https://github.com/openmrs/openmrs-esm-patient-management/tree/main/packages/esm-patient-search-app)
- [Patient lists](https://github.com/openmrs/openmrs-esm-patient-management/tree/main/packages/esm-patient-list-app)
- [Patient registration](https://github.com/openmrs/openmrs-esm-patient-management/tree/main/packages/esm-patient-registration-app)
- [Service queues](https://github.com/openmrs/openmrs-esm-patient-management/tree/main/packages/esm-outpatient-app)

Frontend modules are alternately referred to as `microfrontends` in O3. They get shipped in the ES module format, which explains the `esm-` prefix in their nomenclature. They get loaded into the application indirectly using a special JSON file called an [import map](http://localhost:3001/docs/core-concepts#import-map).

<br />
<Image src="/o3-execution.png" alt="O3 architecture" width={500} height={500} />

This diagram walks through what happens when the application gets executed. The app shell loads configuration files, the import map specifies where frontend modules get fetched from, and [loads frontend modules](/docs/frontend-modules/module-loading).

## Anatomy of a frontend module

### Manifest file (package.json)

Each frontend module has a root-level `package.json` file that defines its dependencies and metadata.

<br />
<Image
  src="/manifest-file.svg"
  alt="Manifest file from a frontend module"
  width={750}
  height={500}
/>

Key things to note from looking at this file include:

- The `name` property which defines the name of the module. This property is used as the module’s unique identifier in the import map.
- The `browser` property which is the entry point of the webpack bundle.
- The `main` property which represents entry point of the frontend module’s source code.

### The application entry point (`index.ts`)

Frontend modules have their [entry point](https://webpack.js.org/concepts/entry-points/) defined in `src/index.ts`.

<br />
<Image
  src="/entrypoint.svg"
  alt="Application entry point"
  width={750}
  height={500}
/>

This file is the entry point of the frontend module. It is the first file that gets executed when the frontend module gets loaded. It is responsible for setting up the frontend module and exporting the module’s configuration. Specifically, in this example:

- It exports an `importTranslation` function which is used to load the module’s translations.
- It also exports two named exports, `root` and `systemAdministrationFormBuilderCardLink`. These are named exports for a page and an extension, respectively. They are used to tell the app shell how to load the frontend module’s content.
- It also exports a `startupApp` function which is used to set up the frontend module. In this case, the frontend module's configuration schema gets defined here, as well as the breadcrumbs for the module.

#### The `startupApp` function

Each frontend module defines a function named `startupApp`. This function performs any setup that should occur at the time the module gets loaded. It returns an object that communicates how the app shell should load the module. The startupApp function should only do the following things:

- define the module's [configuration schema](config.md).
- register [breadcrumbs](breadcrumbs.md).

#### The `importTranslation` function

This is required for translations to work. It tells the frontend application
how to load translation strings. Note that the first argument to
`require.context` is a directory, `../translations`.
That directory must exist at that location relative to the `index.ts` file.

### Static metadata in `routes.json`

The `routes.json` file is used to set up the frontend module's static metadata. These include:

- The `extensions` that frontend module provides.
- The `pages` that frontend module provides.
- The `backend` dependencies that frontend module requires. This is an object that tells the frontend application what OpenMRS server modules the frontend module depends on, and what versions. If these dependencies are not met, administrators will be alerted.

The structure of this static file is dictated by the OpenMRS Routes standard [JSON schema](https://json.openmrs.org/routes.schema.json).

### Creating a page

To create a new page, you'll typically need to follow these steps:

- Create a new React component that will be the page's entry point.
- Add a named export for the page in the `index.ts` file. For example, here's how a page named `root` is exported from the `index.ts` file:

  ```typescript
  export const root = getAsyncLifecycle(() => import("./root"), options);
  ```

- Add a page definition for the new page to the `routes.json` file's `pages` array:

  ```json
  {
    "pages": [
      {
        "component": "root", // maps to the named export in `index.ts`
        "route": "form-builder",
        "online": true,
        "offline": true
      }
    ]
  }
  ```
